1. Git이란
	
	- DVCS : 분산 버전 관리 시스템
	- 소프트웨어 개발 과정에서 소스코드의 변경 사항을 추적하고 관리하는데 사용
	- 많은 개발사에서 사용 중
	- 만약 내가 짠 소스를 어제로 돌리고 싶다면 > 되돌리기를 통해 어제로 돌리기 가능
	- 만약 내가 테스트로 기능을 몇가지 추가하고 싶다면 > 브랜치(branch)로 실험 가능
	- 나의 소스코드를 협업하고 싶다면? > 협업 기능 제공

2. Git의 사용 방법

	- CLI : 명령어 기반 인터페이스, 터미널, 콘솔, 명령 프롬프트 > 직접 명령어 입력
	- CUI : 그래픽 기반 인터페이스, GitHub Desktop, SourceTree > 버튼 메뉴, 아이콘으로 조작

3. 계정 정보 세팅

	- git config --global user.name "jang" > 사용자 이름 저장
	- git config --global user.email "nnini2338@gmail.com" > 사용자 이메일 저장
	- git config --global user.name > 사용자 이름 확인
	- git config --global user.email > 사용자 이메일 확인

	- git config --global init.defaultBranch main > 기본 branch세팅

4. Git의 단계

	- Commit > 변경 사항을 git저장소에 영구적으로 기록하는 작업

	- Working Directory > 소스코드 작업하는 영역, 내가 작업하는 프로젝트 디렉토리
	- Staging Area > 위킹 디렉토리에서 git add 명령어를 통해 추가한 파일이 모인 공간
	- Repository > Staging Area에 있는 소스코드들이 commit 명령을 실행하면 최종적으로 git 저장소에 반영

5. 파일의 생명주기

	- Untracked : Working Directory에 있는 파일이지만 Git으로 버전관리를 하지 않는 상태, 파일이 있으나 한번도 add되지 않은 상태 (처음 상태 git에서 관리 X)
	- Unmodified : 신규 파일이 추가되었을 때, new file 상태와 같음, 파일을 add하여 commit을 1회 이상 한 뒤, 수정사항 없음 (add 후 commit을 완료한 상태)
	- Modified : 파일이 추가된 이후 해당 파일이 수정되었을 때의 상태 (파일을 수정후 git add 및 commit이 안된 상태)
	- Staged : Staging Area에 반영된 상태, git add 한 상태 (git add로 git에 추가 후 commit을 준비한 상태)

6. reset과 revert

	- reset : 원하는 시점으로 돌아간 뒤 이후 내역들 삭제
	- revert : 되돌리기 원하는 시점의 커밋을 거꾸로 실행

7. reset 사용법
	
	- git reset --soft [commit ID] : commit된 파일을 staging area로 돌려놓음 (commit하기 전 상태)
	- git reset --mixed [commit ID] : commit된 파일을 working directiory로 돌려놓음 (add하기 전 상태)
	- git reset --hard [commit ID] : commit된 파일들 중 tracked 파일을 working directory에서 삭제 (커밋 시점으로 되돌림)

8. revert 사용법

	- git revert [commit ID] : 되돌리기 원하는 시점의 커밋을 생성 
		- ex) a - b - c - d에서 git revert c를 실행시 e라는 c로 되돌리는 커밋을 생성 결과적으로 a - b - c- d - e가 됨

9. 실습 종료 후, 계정 초기화

	- git config --global --upset user.name > 사용자 이름 삭제
	- git config --global --upset user.email > 사용자 이메일 삭제
	- git config --global --list > 로 계정 삭제 확인 가능

10. Branch란?

	- 특정 시점에서 코드의 버전을 나누어 별도로 관리 할 수 있도록 하는 기능
	- 기본 브랜치에서 나뭇가지처럼 새로운 브랜치를 생성하여 기능 추가, 오류 수정등을 가능하게 함
	- 분기된 가지 : 특정 시점에서 갈라져서 독립적인 작업 가능

11. Branch 명령어 종류

	- git branch
	- git branch <생성할 브랜치>
	- git switch <이동할 브랜치>
	- git switch -c <생성,이동할 브랜치>
	- git branch -m <기존 브랜치이름> <수정할 브랜치 이름>
	- git branch -d <삭제할 브랜치>

12. merge와 rebase 차이

	- 모두 branch를 통합할 때 사용

	- merge : 두 브랜치의 변경이력을 유지하며 병합 커밋을 만들어 통합함
		- 분기와 병합 흔적이 남음
	- rebase : 두 브랜치를 통합시킴 
	
13. 병합된 브랜치 삭제

	- git branch -d <브랜치명>

14. rebase중 충돌 발생

	- git rebase --abort > rebase전으로 복구


15. git hub란?

	- git : 버전 관리 도구, 분산 버전 관리 시스템
	- github : git저장소를 호스팅하고 공동작업 하기 위한 플랫폼, 협업 관리 도구, 오픈소스 

16. 저장소 gut-hub에 넣기

	- git remote add origin (github주소) > 내 로컬 Git 저장소에 GitHub 저장소 주소를 등록
	- git branch -M main
	- git push -u origin main > 내 로컬의 main branch를 GitHub의 main branch로 push(업로드)

17. GitHub Push, Pull

	- git push : 로컬 저장소에서 만든 변경 사항(커밋)을 원격 저장소로 업로드, 로컬에서 원격으로 데이터 전송, 코드 공유 및 협업 필수
		- 내 수정사항을 깃허브에 올리는 단계
	git add
	git commit -m "커밋 메시지"
	git push origin <브랜치명>
	
	- access token 확인 필수

	- git pull : 원격 저장소의 변경 사항을 로컬 저장소로 가져오는 명령어
		- 깃허브의 내용을 내 로컬로 내려받는 단계 
	git pull origin main

18. 다른 브랜치로 push를 원한다면

	- git push origin <브랜치명>

19. IP(Internet Protocol)

	- 데이터를 주고 받기 위한 규칙
	- 네트워크에 연결된 장치마다 고유한 IP주소를 부여하여 네트워크 상에 그 장치를 구분
	- Host에 대한 식별자
	- ex) 대한민국 행정 체계 : Network, 개인 : Host, 주민번호 : IP주소

20. IP주소의 구조

	- IPv4 = 4옥텟(8비트) > 2의32승 = 43억개 > 전세계인구가 81억명이므로 IP주소 부족
	- IPv6 = 128bit

21. IPv4 주소 구조

	- 0~255.0~255.0~255.0~255
	- IP주소는 8bit씩 끊어서 표시
	- Network ID + Host ID
	- Network ID : 전세계의 호스트를 관리하기 힘드니 국가별 Network ID를 부여해서 네트워크 식별
	- Host ID : 호스트 부분은 네트워크에 연결되어 있는 디바이스를 식별한다
	- 네트워크ID와 호스트ID를 구분하는 것은? 서브넷 마스크에 따라

22. 사설 Private IP 범위

	- A클래스 : 10.0.0.1 ~ 10.255.255.254 (10.~.~.~) 나머지 0~127까지는 공인
	- B클래스 : 172.16.0.1 ~ 172.31.255.254 (172.16~31.~.~) 나머지 128~191은 공인
	- C클래스 : 192.168.0.1 ~ 192.168.255.254 (192.168.~.~) 나머지 192~223은 공인

23. 서브넷 마스크

	- 서브넷 마스크 : Network ID의 길이를 나타내는 것 (/n)
	- A클래스 : /8
	- B클래스 : /16
	- C클래스 : /24

24. CIDR 표현식
	
	- IP : 172.22.65.33이고 Subnet : 255.255.0.0이라면 CIDR표현식은 172.22.65.33/16이다
	- Network ID = 10101100.00010110.00000000.00000000 > 172.22.0.0


25. 서브네팅

	- A클래스의 호스트 IP개수 : 2의 24승 - 2
	- B클래스의 호스트 IP개수 : 2의 16승 - 2
	- C클래스의 호스트 IP개수 : 2의 8승 - 2
	- 2를 빼는 이유 네트워크 주소와 브로드캐스트 주소 제외

26. 브로드 캐스트 주소

	- 호스트 ID가 모두 1인 주소로 네트워크의 모든 호스트로 데이터를 전달하기 위한 통로로서의 주소 : 네트워크 ID + 호스트 비트 전부 1
	
	- ex) 네트워크 : 192.168.25.0/24
		네트워크 주소 : 192.168.25.0
		브로드캐스트 주소 : 192.168.25.255
		사용가능한 호스트 : 192.168.25.1~254

27. 서브네팅

	- /24는 254개의 호스트 사용가능 하지만 100개만 필요하다면 /25로 126개의 호스트 공간으로 만들 수 있음

28. 예제 1

	- IP 주소가 191.168.25.0이고 서브넷마스크가 255.255.252.0일 때, 네트워크주소와 브로드캐스트 주소를 쓰시오.

29. 예제 2

	- 129.200.10.16/22의 네트워크주소와 브로드캐스트 주소를 쓰시오.

30. Aurora RDS의 특징

	- 기존 코드, 도구 그대로 사용가능
	- 용량 자동 증감 : 10GB부터 시작, 10GB단위로 용량 증가(최대 128TB)
	- 고성능 분산 스토리지 : 6중 복제, 내결함성 제공
		- 각 AZ(가용영역)마다 2개의 데이터복제본 저장 X 최소 3개 이상의 AZ = 6중 복제 > 4개의 AZ라면 1 1 2 2식으로 복제
		- 내결함성 : 시스템의 일부에 장애가 발생해도 전체 서비스가 멈추지 않고 계속 동작하는 시스템
	- Aurora는 데이터를 10GB단위의 세그먼트로 쪼갬 > 1TB면 약 100개의 세크먼트로 나눔
	- 이 세그먼트안에 다시 데이터 블록단위로 복제 저장 

31. Quorum(쿼럼) 모델 : 내결함성, 고가용성

	- 데이터를 3개 AZ, 총 6개 복제본에 분산 저장
	- 쓰기 작업 : 최소 4개 복제본이 응답해야 완료 > 2개까지 손실 OK
	- 읽기 작업 : 최소 3개 복제본이 응답해야 완료 > 3개까지 손실 OK

	- Quorum(쿼럼) 모델 : 다수결의 원리와 비슷하게 여러 복제본 중 일정 개수 이상 응답하면 작업을 성공적으로 처리하는 방식
	- Quorum : 의사 결정에 필요한 최소 인원, 합의를 위한 최소 응답 수
	- Self-healing : 손실된 복제본은 자가 치유, 지속적으로 손실된 부분을 검사 후 복구

32. Aurora의 두 가지 레벨

	- 스토리지 레벨
		- 데이터가 저장되는 공간
		- Aurora는 6개 복제본을 유지
		- Quorum모델을 통해 내결함성과 고가용성 보장

	- 컴퓨팅 레벨
		- 데이터를 읽고 쓰는 DB 인스턴스 (Writer/Reader)
		- Single-Master : Writer 1개 + 여러 Reader(최대 15개)
		- Multi-Master : 모든 인스턴스가 Writer가능

33. Single-Master

	- 구성 : Writer인스턴스 1개 + Reader인스턴스 최대 15개
	- 동작방식 : 쓰기 작업은 반드시 Writer에서만 수행, 읽기 작업은 Reader인스턴스로 분산 처리
	- 복제방식 : Async 복제(비동기 : 약간의 지연 있음)로 Reader와 데이터 동기화
	- 고가용성 : Writer 인스턴스 장애 발생시 Reader중 하나가 Writer로 자동 승격(Failover)
	- 특징 : 대부분의 워크로드(처리해야할 작업의 양과 종류)에 적합, 읽기 트래픽 확장에 강점

34. Aurora Global DataBase

	- 재해 복구 용도 활용
		- Primary Region 장애 시, Secondary Region을 빠르게 승격 (Failover) 가능
		- RPO(복구 목표 시점) : 1초미만 > 장애 시 최대 1초치 데이터만 손실됨
		- RTO(복구 목표 시간) : 1분 미만 > 장애 발생 후 서비스가 복구되어 정상 운영까지 걸리는 시간

35. 병렬 쿼리

	- 

36. Binlog

37. AWS Aurora 백업 방법

38. Copy-on-Write 방식















