AWS RDS

- Amazon RDS
    
    - AWS에서 제공하는 완전 관리형 관계형 데이터베이스 서비스
    - 데이터베이스 설치, 운영, 확장, 패치, 백업 등을 자동 관리
    - 사용자는 애플리케이션 개발에 집중 가능함

    - Amazon RDS는 관계형 데이터베이스를 클라우드에 손쉽게 운영할 수 있도록 하는 서비스
    - 서버 설치나 백업,패치 같은 번거로운 작업을 AWS가 함
    - 개발자는 비지니스 로직에 집중

- RDS전의 기존 데이터베이스의 한계

    - 온프레미스 DB : 직접 설치, 운영(직접 설치 및 관리 필요), 확장성 한계(서버 자원 한정으로 데이터나 트래픽 많을시 확장 어려움),
	- 장애 복구 부담(서버나 DB에 장애가 생기면 복구 직접 해야 함)
    - 오픈소스 DB : 무료이지만 성능, 안정성 제약, 전문 튜닝(사용자가 직접 최적화 필요) 필요
    - 상용 DB : 안정적이지만 라이선스 비용 비쌈, 벤더 종속성(특정 회사에 계속 의존해 다른 제품 사용 X 종속됨)

- RDS 엔진의 종류

    - MySQL : 오픈소스, 대중적
    - PostgreSQL : 확장성·표준 SQL 강점
    - MariaDB : MySQL 기반 오픈소스
    - Oracle : 안정성·기업용 기능 풍부(라이선스 비용있음)
    - MS SQL Server : Windows 생태계와 강력 통합

- AWS RDS의 장점

    - 인프라 관리 부담 감소
    - 자동화 기능 (백업,모니터링,패치등)
    - 고가용성 제공 (Multi-AZ배포)
    - 필요 시 수 분 내에 확장 가능
    - 안정적으로 DB사용은 비용 부담 발생 그러므로 AWS와 같은 관리형 서비스 도입하는 추세

- Aurora RDS(기본 RDS의 업그레이드)의 장점

    - 완전 관리형 관계형 DB엔진
    - MySQL PostgreSQL 호환 + 성능 극대화 > MySQL 대비 5배, PostgreSQL 대비 3배 성능
    - RDS 엔진 대비 고성능이지만 저비용(비싸긴 한데 성능 대비론 RDS보다 좋은편)
    - 클라우드 네이티브 아키텍처(처음부터 클라우드 환경을 위해 설계됨 운영의 유연함 추가)

- Aurora RDS의 특징

    - 기존 쓰던 코드 도구 그대로 사용 가능
    - 용량 자동 증감 : 10GB부터 시작, 10GB단위로 용량 증가 (최대 128TB)
    - 고성능 분산 스토리지 : 6중 복제, 내결함성 제공
	- 내결함성 : Fault Tolerance, 시스템 일부에 장애가 발생해도 전체 서비스가 멈추지않고 계속 동작하는 능력
	- 각 AZ마다 2개의 데이터 복제본 저장 X 최소 3개 이상의 AZ = 6중 복제
    - Aurora는 데이터를 10GB단위의 세그먼트로 쪼갬 ex) 1TB면 약 100개의 10GB 세그먼트로 나눔
	- 세그먼트 : 데이터를 관리하기 위해 쪼갠 큰 덩어리
	- 그 세그먼트를 다시 몇 MB의 데이터 블록 단위로 나눔 > Aurora에 여러번 저장함 (복구가 더 빠르고 효율적임)

- Quorum(쿼럼) 모델 : 내결함성, 고가용성

    - Quorum(쿼럼) 모델 : 다수결의 원리와 비슷하게 여러 복제본 중 일정 개수 이상응답시 작업을 성공적으로 처리하는 방식
    - Quorum(쿼럼) : 의사 결정에 필요한 최소 인원, 합의를 위한 최소 응답 수
    - Self-healing(자가 복구) : 손실된 복제본은 자가 치유, 지속적으로 손실된 부분을 검사 후 복구

    - ex) Aurora에서는 3개의 AZ에 총 6개의 복제본을 분산 저장
	- 쓰기 작업 : 최소 4개의 복제본이 응답해야함
	- 읽기 작업 : 최소 3개의 복제본이 응답해야함

- Aurora의 두가지 레벨

    - 스토리지 레벨
	- 데이터가 저장되는 공간
	- Aurora는 6개의 복제본 유지
	- Quorum 모델을 통해 내결함성과 고가용성 보장
    
    - 컴퓨팅 레벨
	- 데이터를 읽고 쓰는 DB 인스턴스(Writer/Reader)
	- Single-Master : Writer 1개(하나의 인스턴스가 쓰기 담당) + 여러 Reader (여러 인스턴스가 읽기 담당)
	- Multi-Master : 모든 인스턴스가 Writer 가능

- Single-Master

    - 구성
	- Writer 인스턴스 : 1개 (쓰기 전용)
	- Reader 인스턴스 : 최대 15개 (읽기 전용 Replica)

    - 동작방식
	- 쓰기 작업은 반드시 Writer에서 수행
	- 읽기 작업은 Reader 인스턴스로 분산 처리(트래픽 부하 다운)

    - 복제방식
	- Async 복제(비동기 : 약간의 지연 시간이 있음 대신 읽기 처리량을 크게 늘림)로 Reader와 데이터 동기화 

    - 고가용성
	- Writer 장애시 Reader중 하나가 Writer로 자동 승격

    - 특징
	- 대부분의 워크로드(처리해야할 작업의 종류와 양)에 적합
	- 읽기 트래픽 확장에 강점 

- Aurora Global Datebase

    - 전 세계 리전 간 데이터 공유
	- 1초 미만 지연 시간으로 다른 리전에서 읽기 가능
	- 다국적 서비스, 글로벌 사용자 대상 서비스 최적화

    - 재해 복구 용도 활용
	- Primary Region 장애시, Secondary Region을 빠르게 승격 가능(Primary로)
	- RPO(Recovery Point Objective, 복구 목표 시점): 1초 미만
	    - 장애 시 데이터 손실 허용 범위 최대 1초치만 손실

    - 읽기 전용 확장성(Read Scalability)
	- 보조 리전(Secondary Region)마다 최대 16개의 Reader 인스턴스 생성 가능
	- 글로벌 서비스의 트래픽을 여러 리전에 분산 처리

    - 제한 사항
	- Writer는 Primary Region에만 존재 (Single-Master 기반)
	- Region 간 복제는 비동기(Asynchronous) 복제 방식 > 약간의 지연 가능

- 병렬 쿼리

    - 온프레미스에서 Full Scan을 하면 시간 많이 소모함 떠 빨리 처리하기 위한게 > AWS Aurora

    - AWS Aurora : 스토리지에 분산 저장된 세그먼트를 스토리지 노트에서 직접 병렬 스캔
	- 빠름 : 수억 건 이상의 대규모 데이터를 처리할 때, 병렬적으로 분산 스캔 > 응답 시간 단축
	- 부하 분산 : CPU.메모리를 쓰지 않고 스토리지 노드가 작업을 대신 수행
	- OLAP(Online Analytical Processing)최적화 : 분석성 쿼리(집계, 리포트)에 매우 적합

    - AWS aurora 제약사항
	- Aurora MySQL 전용 (현재는 MySQL 5.6, 5.7 호환 버전에만 제공)
	- 낮은 인스턴스 타입에서는 미지원 (t2, t3계열)
	- 트랙잭션성 OLTP(Online Transzction Processing) 쿼리에는 큰 장점 없음 > 주로 OLAP/분석용
    
   - OLTP : 실시간으로 많은 사용자가 거래하는 시스템 ex) 은행 계좌 이체, 상품 주문, 결제
	- 특징 : 실시간 처리, 짧은 트랜잭션, 정합성 중요, 분석보단 처리
   
    - OLAP : 온라인 분석 처리 시스템, 많은 양의 데이터를 분석하고 요약하는 시스템 ex) 매출 합계, 판매 추세 분석등
	- 특징 : 분석 중심, 복잡한 쿼리, 대량 데이터 처리, 실시간성보다 정확성이 중요, 
		- 데이터 웨어하우스(데이터 따로 저장하는 구조에서 주로 사용)

- MySQL 백업 (Binlog 기반)
    
    - 데이터 변경(CRUD 생성, 읽기, 수정, 삭제) > Binlog(Binary Log)에 기록

    - Binlog : 데이터 변경 내역을 기록하는 로그 파일
	- 작업 : 데이터 추가, 수정, 삭제, 테이블 생성등 스키마 변경

    - ex) INSERT INTO Orders VALUES (101, '상품A', 3);
	-> binlog에 INSERT 이벤트 기록됨
    - 단 SQL문 그대로 binlog에 저장하는게 아닌 압축된 이진(Binlog)포맷으로 저장됨(사람이 읽기 위한게 아닌 시스템이 읽기 위한 것)
	-> Replica DB(복제본)는 Binlog를 읽고 해당 이벤트를 재실행하여 Primary(원본)와 동기화

    - 사용하는 이유
	- 스토리지 통제 복제 : DB 파일를 전체 복사하여서 용량이 크고 파일 포맷에 의존적임(서버 환경이 다르면 안 맞음)
	- Binlog 이벤트 복제 : 변경내역(CRUD)만 복사하여서 가볍고 이식성과 유연성이 높음

- AWS Aurora 백업 방법

    - 스토리지 기반 백업
	- Aurora는 Binlog를 사용하지 않고 스토리지레벨에서 자동 백업
	- 변경된 데이터 블록을 Amazon S3에 저장
	- PITR(Point-In-Time Recovery, 시점 복구) 지원(특정 시점으로 복구 가능)

    - 자동 백업
	- 기본 제공, 보관 기간 1~35일
	- Amazon S3에 저장 > 높은 내구성(11 9s, 99.99999%)
	- 특정 시점 복구(PITR)지원
	- 사용자가 별도로 신경 안써도 자동 수행

    - 수동 백업(Snapshot)
	- 사용자가 특정 시점에 스냅샷 생성
	- 장기 보관 가능
	- 다른 리전으로 복사 가능
	- 특정 시점 그대로 DB 복제본을 만들어서 저장함

    - 리전 간 백업
	- 한 리전에서 다른 리전으로 DB데이터를 복사하는 것
	- 스토리지는 리전 단위 리소스 > 다른 리전과 직접 공유 불가
	- Binlog 기반 Read Replica (MySQL 전통 복제 방식) 느리고 부하 발생 가능
	- Aurora Global Database (Aurora 전용, 더 빠르고 효율적) 사용 가능

- Aurora Cloning

    - 원리
	- 오리지널 클러스터를 그대로 두고 클론 클러스터를 새로 생성 > 하지만 데이터 전체 복사는 X, 대신 기존 스토리지 데이터 공유

    - Copy-on-Write 방식
	- 클론은 원복과 같은 스토리지를 바라봄
	- 새로운 데이터 변경이 발생한다면?
	    - 원본의 블록은 그대로 둠
	    - 변경된 블록만 새로운 스토리지에 복사 후 기록 > 읽기는 공유
	- 결과 : 공유 가능한 블록 : 그대로 사용 / 수정된 블록 : 분리 저장

    - 장점
	- 속도 : 수 TB급 DB도 몇 분 만에 클로닝 가능 (풀 카피 X)
	- 비용 절감 : 변경된 블록만 추가 저장 > 전체 용량 대비 매우 저렴
	- 유연성 : 원본 클러스터를 지워도 클론은 독립적으로 동작

- Aurora Backtrack

    - 기존 DB를 특정 시점으로 되돌리는 기능
    - 새로운 DB를 생성하지 않고, 기존 DB를 롤백
    - 실수 복구에 최적화 (ex WHERE 없이한 DELETE, 잘못된 UPDATE)
    - MySQL 오픈소스에는 없는 기능 (Aurora MySQL 전용)
    - Oracle DB의 Flashback Database와 유사
    - 스냅샷 복구는 새 DB 생성 > 데이터 복원 > 느리고 복잡
    - Backtrack은 클러스터 전체를 즉시 되돌림 > 빠르고 간편
    - DBA(데이터베이스사용자) 실수를 신속히 수정할 수 있음
    - PostgreSQL 버전에서는 지원하지 않음 Aurora MySQL이여야 가능함

- Aurora Multi-Master

    - Single-Master 한계
	- Writer는 1개 뿐 > 쓰기 병목 발생 (속도가 느림)
	- 장애 시 Failover 필요 > 수 초간 다운타임 (몇 초 몇 분간 서비스 불가)

    - Multi-Master 필요성
	- 모든 인스턴스가 Writer 역할 수행 > 병목 해소
	- 무중단 고가용성 + 쓰기 확장성 확보 
		> 어느 인스턴스가 장애가 나도 다른 인스턴스 쓰기 바로 계속 가능, 트래픽이 많을 때 인스턴스 추가로 쓰기 처리량 증가

- Multi-Master
    
    - 모든 Writer 인스턴스가 동일 Storage Volume 공유 > 한 곳에 저장, 모든 노드가 같은 데이터를 보도록 함
    - 모든 인스턴스가 읽기/쓰기 동시 처리 가능
    - 최대 4개의 Writer 노드 지원 (현재 한계 4개)
    - 트랜잭션 충돌 시 Aurora가 조정 (첫 커밋 우선) > 두 개의 비슷한 Writer노드가 동시에 실행되서 충돌시 자동으로 Aurora가 조정
    - 각 Writer 노드는 독립적 > 정지/재부팅/삭제가 다른 노드에 영향 없음 > Writer2를 정지하거나 재부팅해도 Writer1,3은 계속 서비스 가능
    - Writer 장애시 Failover 필요 없음 > 다른 Writer가 즉시 처리
    - 목표 : 지속적인 가용성 제공 (항상 켜져 있고, 접근 가능하고, 데이터를 읽고 쓸 수 있는 상태) 

- Multi-Master 사용 상황

    - Multi-tenant 서비스(SaaS)
	- SaaS = 한 플랫폼에서 여러 고객사가 서비스 이용
	- 고객사마다 데이터 격리가 필요할 때 > 각 노드에 독립 DB를 배치하며 전체 시스템은 무중단 운영
	- 여러 고객이 동시에 데이터를 써도 병목 없이 처리 가능
	- 다운 타임 없는 고가용성 중요 > 한 Writer이 멈춰도 다른 Writer이 처리

    - Sharding 적용 대규모 애플리케이션
	- 데이터가 너무 많으면 한 DB가 감당 못함 > 수평 확장 필요 > 샤드별 Writer을 나눠 부하 분산 가능
	- 사용자수 데이터 크기 폭증 시 > 병목 및 다운타임 없이 수평 확장 가능, 무중단 운영 가능


    - Sharding = 데이터를 작은 단워로 나눠 여러 DB에 분산 ex) User ID 1~100만 > Shard A / User ID 100만 ~ 200만 > Shard B
	- 특정 Shard에 부하 집중시 Hotspot(특정 데이터 파티션에만 트래픽이 집중되는 현상) 발생 단점 있음

- Aurora Multi-Master의 단점

    - Aurora MySQL 전용
    - Backtrack(특정 시점 롤백), Parallel Query(쿼리 병렬 처리), Global Database(다른 리전과 자동 동기화) 사용불가 > Single-Master에서는 사용가능
    - 특정 Writer 인스턴스만 Binlog 활성화 가능 : 모든 Writer에서는 사용 불가
    - 클로닝도 일부 제약 있음 > 복제나 테스트용 DB 만들 때만 클로닝 가능
    - 아키텍쳐 복잡함 : 동일 Row에 대한 동시 Write 시 충돌 가능
	- 첫 번째 커밋 성공, 나머지는 에러 반환
    - 충돌 처리 로직은 애플리케이션이 직접 고려해야함
